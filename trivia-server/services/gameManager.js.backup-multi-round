// gameManager.js - Complete fix for mobile experience and game flow
class GameManager {
  constructor(io, db) {
    this.io = io;
    this.db = db;
    this.games = new Map();
    this.questionTimers = new Map();
    this.lightningTimers = new Map();
    this.fadeTimers = new Map();
  }

  // Create a new game with questions
  createGame(sessionId, questions) {
    console.log(`[GameManager] Creating game for session ${sessionId} with ${questions.length} questions`);

    // Add extra questions for speed round
    const lightningQuestions = this.generateLightningQuestions(20);

    this.games.set(sessionId, {
      sessionId,
      questions: [...questions, ...lightningQuestions],
      status: 'waiting',
      currentRound: 1,
      currentQuestion: 0,
      players: new Map(),
      playerNicknames: new Map(), // Store nicknames
      startedAt: null,
      showingIntro: false, // ADD THIS LINE - Flag to pause timeouts during intros
      roundScores: {
        1: new Map(),
        2: new Map(),
        3: new Map(),
        4: new Map() // Speed round
      },
      lightningRound: {
        questionsAnswered: 0,
        frozenPlayers: new Set(),
        startTime: null,
        currentQuestionIndex: 30,
        active: false
      }
    });

    return true;
  }

  // Add player to game
  addPlayer(sessionId, clientId, nickname) {
    const game = this.games.get(sessionId);
    if (!game) return false;

    game.playerNicknames.set(clientId, nickname);

    if (!game.players.has(clientId)) {
      game.players.set(clientId, {
        totalScore: 0,
        correctCount: 0,
        currentStreak: 0,
        longestStreak: 0,
        roundCorrect: { 1: 0, 2: 0, 3: 0, 4: 0 },
        hasAnswered: false,
        nickname: nickname
      });
    }

    // Emit updated player count and list to host
    this.emitPlayerUpdate(sessionId);
    return true;
  }

  // Emit player update to host
  emitPlayerUpdate(sessionId) {
    const game = this.games.get(sessionId);
    if (!game) return;

    const playerList = Array.from(game.players.entries()).map(([clientId, player]) => ({
      clientId,
      nickname: player.nickname,
      score: player.totalScore
    }));

    this.io.to(sessionId).emit('PLAYER_UPDATE', {
      playerCount: game.players.size,
      players: playerList
    });
  }

  // Generate speed round questions
  generateLightningQuestions(count) {
    const questions = [];
    for (let i = 0; i < count; i++) {
      questions.push({
        id: `lightning_${i}`,
        text: `Speed Question ${i + 1}`,
        question: `Speed Question ${i + 1}`,
        correct_answer: 'Answer A',
        incorrect_answers: ['Answer B', 'Answer C', 'Answer D'],
        all_answers: ['Answer A', 'Answer B', 'Answer C', 'Answer D'],
        correctAnswerIndex: 0,
        difficulty: 'speed',
        category: 'Speed Round'
      });
    }
    return questions;
  }

  // Start the game with countdown
  startGame(sessionId) {
    console.log(`[GameManager] Starting game for session: ${sessionId}`);

    const game = this.games.get(sessionId);
    if (!game) {
      console.error(`[GameManager] No game found for session: ${sessionId}`);
      return false;
    }

    // Start countdown from 5
    let countdown = 5;
    const countdownInterval = setInterval(() => {
      this.io.to(sessionId).emit('COUNTDOWN', {
        count: countdown,
        message: countdown > 0 ? `Game starting in ${countdown}...` : 'GO!'
      });

      countdown--;

      if (countdown < 0) {
        clearInterval(countdownInterval);

        game.status = 'playing';
        game.startedAt = new Date();
        game.currentRound = 1;
        game.currentQuestion = 0;

        // Show round intro with 10-second countdown
        this.showRoundIntro(sessionId, 1);
      }
    }, 1000);

    return true;
  }

  // Show round intro with sponsor and countdown
  showRoundIntro(sessionId, roundNumber) {
    console.log(`[GameManager] Showing round ${roundNumber} intro for session ${sessionId}`);

    const game = this.games.get(sessionId);
    if (!game) return;

    // Set flag to indicate we're showing an intro
    game.showingIntro = true; // ADD THIS LINE

    const sponsors = {
      1: 'Sponsor A',
      2: 'Sponsor B',
      3: 'Sponsor C',
      4: 'RSN8TV' // Speed round sponsor
    };

    let countdown = 5;

    // Initial emit
    this.io.to(sessionId).emit('ROUND_INTRO', {
      round: roundNumber,
      sponsor: sponsors[roundNumber],
      difficulty: this.getDifficultyForRound(roundNumber),
      points: this.getBasePoints(roundNumber),
    });

    // Countdown interval
    const introInterval = setInterval(() => {
      countdown--;
      if (countdown <= 0) {
        clearInterval(introInterval);

        // Clear the showingIntro flag
        game.showingIntro = false; // ADD THIS LINE

        // Start questions after intro
        this.nextQuestion(sessionId);
      }
    }, 1000);
  }

  // Move to next question
  nextQuestion(sessionId) {
    // FIX: Block if intro is showing - FIXED SYNTAX ERROR HERE
    if (this.games.get(sessionId)?.showingIntro === true) {
      console.log('[GameManager] nextQuestion BLOCKED - intro showing');
      return;
    }
    
    const game = this.games.get(sessionId);
    if (!game || game.status !== 'playing') {
      console.log(`[GameManager] Game not in playing state for session: ${sessionId}`);
      return;
    }

    // Don't start next question if we're showing an intro
    if (game.showingIntro) { // ADD THIS CHECK
      console.log(`[GameManager] Skipping nextQuestion - showing intro for session ${sessionId}`);
      return;
    }

    // Handle speed round differently
    if (game.currentRound === 4) {
      this.handleLightningQuestion(sessionId);
      return;
    }

    // Regular rounds (1-3)
    const questionIndex = (game.currentRound - 1) * 10 + game.currentQuestion;

    if (questionIndex >= 30) { // After 3 rounds, start speed round
      game.currentRound = 4;
      game.currentQuestion = 0;
      this.startLightningRound(sessionId);
      return;
    }

    const question = game.questions[questionIndex];
    if (!question) {
      console.error(`[GameManager] Question not found at index ${questionIndex}`);
      return;
    }

    // Clear any existing timers
    this.clearQuestionTimer(sessionId);
    this.clearFadeTimers(sessionId);

    // Prepare question data
    const questionData = {
      questionId: question.id || `q${questionIndex}`,
      question: question.text || question.question,
      answers: question.all_answers || [],
      category: question.category || 'General',
      difficulty: question.difficulty || this.getDifficultyForRound(game.currentRound),
      round: game.currentRound,
      questionNumber: game.currentQuestion + 1,
      totalQuestions: 10,
      timeLimit: this.getTimeLimit(game.currentRound),
      points: this.getBasePoints(game.currentRound),
      fadeAnswers: true
    };

    // Store current question info
    game.currentQuestionData = {
      ...question,
      startTime: Date.now(),
      answered: new Set(),
      autoAdvanceStarted: false
    };

    // Reset hasAnswered flag for all players
    game.players.forEach(player => {
      player.hasAnswered = false;
    });

    // Emit question to all players and host
    this.io.to(sessionId).emit('QUESTION_READY', questionData);

    // Update host display
    this.emitGameState(sessionId);

    // Start question timer
    this.startQuestionTimer(sessionId);
  }

  // Emit current game state to host
  emitGameState(sessionId) {
    const game = this.games.get(sessionId);
    if (!game) return;

    const playerScores = Array.from(game.players.entries()).map(([clientId, player]) => ({
      clientId,
      nickname: player.nickname,
      score: player.totalScore,
      hasAnswered: player.hasAnswered,
      streak: player.currentStreak
    }));

    this.io.to(sessionId).emit('GAME_STATE_UPDATE', {
      round: game.currentRound,
      question: game.currentQuestion + 1,
      playerScores: playerScores,
      isSpeedRound: game.currentRound === 4
    });
  }

  // Start speed round
  startLightningRound(sessionId) {
    const game = this.games.get(sessionId);

    game.lightningRound.active = true;

    // Show speed round intro with countdown
    this.showRoundIntro(sessionId, 4);
  }

  // Handle speed round questions
  handleLightningQuestion(sessionId) {
    const game = this.games.get(sessionId);

    if (!game.lightningRound.startTime) {
      game.lightningRound.startTime = Date.now();

      // Start 30-second timer
      const lightningTimer = setTimeout(() => {
        this.endLightningRound(sessionId);
      }, 30000);

      this.lightningTimers.set(sessionId, lightningTimer);
    }

    const questionIndex = game.lightningRound.currentQuestionIndex;

    const question = game.questions[questionIndex];
    if (!question || questionIndex >= game.questions.length) {
      this.endLightningRound(sessionId);
      return;
    }

    const timeElapsed = (Date.now() - game.lightningRound.startTime) / 1000;
    const timeRemaining = Math.max(0, 30 - timeElapsed);

    if (timeRemaining <= 0) {
      this.endLightningRound(sessionId);
      return;
    }

    const questionData = {
      questionId: question.id,
      question: question.text || question.question,
      options: question.all_answers || [],  // FIXED: Changed from 'answers' to 'options' to match frontend
      category: 'Speed Round',
      difficulty: 'speed',
      round: 4,
      questionNumber: game.lightningRound.questionsAnswered + 1,
      timeRemaining: Math.floor(timeRemaining),
      points: 50,
      isLightning: true
    };

    game.currentQuestionData = {
      ...question,
      startTime: Date.now(),
      answered: new Set(),
      isLightning: true
    };

    console.log(`[GameManager] Sending speed question ${questionData.questionNumber}`);
    this.io.to(sessionId).emit('LIGHTNING_QUESTION', questionData);

    // Update host
    this.emitGameState(sessionId);
  }
  // End speed round
  endLightningRound(sessionId) {
    const timer = this.lightningTimers.get(sessionId);
    if (timer) {
      clearTimeout(timer);
      this.lightningTimers.delete(sessionId);
    }

    const game = this.games.get(sessionId);
    game.lightningRound.active = false;

    this.io.to(sessionId).emit('LIGHTNING_ROUND_COMPLETE', {
      questionsAnswered: game.lightningRound.questionsAnswered
    });

    setTimeout(() => {
      this.endGame(sessionId);
    }, 1500);
  }

  // Start timer for current question
  startQuestionTimer(sessionId) {
    const game = this.games.get(sessionId);
    if (!game) return;

    const timeLimit = this.getTimeLimit(game.currentRound) * 1000;

    const timer = setTimeout(() => {
      console.log(`[GameManager] Time's up for question in session ${sessionId}`);
      this.handleQuestionTimeout(sessionId);
    }, timeLimit);

    this.questionTimers.set(sessionId, timer);

    // Start progressive answer fading for regular rounds
    if (game.currentRound <= 3) {
      this.startProgressiveFading(sessionId);
    }
  }

  // Start progressive fading of incorrect answers
  startProgressiveFading(sessionId) {
    const game = this.games.get(sessionId);
    if (!game || !game.currentQuestionData) return;

    const correctIndex = game.currentQuestionData.correctAnswerIndex;
    const totalAnswers = game.currentQuestionData.all_answers.length;

    // Get all incorrect answer indices
    const incorrectIndices = [];
    for (let i = 0; i < totalAnswers; i++) {
      if (i !== correctIndex) incorrectIndices.push(i);
    }

    // Shuffle incorrect indices
    const shuffled = [...incorrectIndices];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }

    // Fade first incorrect answer at 10 seconds
    const firstFadeTimer = setTimeout(() => {
      this.io.to(sessionId).emit('FADE_ANSWERS', {
        fadeIndices: [shuffled[0]],
        keepIndices: [correctIndex, shuffled[1], shuffled[2]]
      });
    }, 5000); // 15s - 10s = 5s delay

    // Fade second incorrect answer at 5 seconds
    const secondFadeTimer = setTimeout(() => {
      this.io.to(sessionId).emit('FADE_ANSWERS', {
        fadeIndices: [shuffled[0], shuffled[1]],
        keepIndices: [correctIndex, shuffled[2]]
      });
    }, 10000); // 15s - 5s = 10s delay

    // Store timers for cleanup
    this.fadeTimers.set(sessionId, [firstFadeTimer, secondFadeTimer]);
  }

  // Clear fade timers
  clearFadeTimers(sessionId) {
    const timers = this.fadeTimers.get(sessionId);
    if (timers) {
      timers.forEach(timer => clearTimeout(timer));
      this.fadeTimers.delete(sessionId);
    }
  }

  // Clear question timer
  clearQuestionTimer(sessionId) {
    const timer = this.questionTimers.get(sessionId);
    if (timer) {
      clearTimeout(timer);
      this.questionTimers.delete(sessionId);
    }
  }

  // Handle question timeout
  handleQuestionTimeout(sessionId) {
    const game = this.games.get(sessionId);

    // Don't process timeout if game doesn't exist or we're showing an intro
    if (!game || game.showingIntro) return; // MODIFY THIS LINE

    this.clearFadeTimers(sessionId);

    // Emit time up event
    this.io.to(sessionId).emit('TIME_UP', {
      correctAnswer: game.currentQuestionData.correctAnswerIndex || 0,
      correctAnswerText: game.currentQuestionData.correct_answer
    });

    // Auto-advance after timeout
    setTimeout(() => {
      this.moveToNextQuestion(sessionId);
    }, 2000);
  }

  // Move to next question or round
  moveToNextQuestion(sessionId) {
    const game = this.games.get(sessionId);
    if (!game) return;

    game.currentQuestion++;

    // Check if round is complete (10 questions per round)
    if (game.currentQuestion >= 10 && game.currentRound <= 3) {
      if (game.currentRound >= 3) {
        // Start speed round
        game.currentRound = 4;
        game.currentQuestion = 0;

        this.io.to(sessionId).emit('ROUND_COMPLETE', {
          round: 3,
          nextRound: 4
        });

        setTimeout(() => {
          this.startLightningRound(sessionId);
        }, 2000);
      } else {
        // Move to next round
        game.currentRound++;
        game.currentQuestion = 0;

        console.log(`[GameManager] Moving to round ${game.currentRound} for session ${sessionId}`);

        // Emit round complete event
        this.io.to(sessionId).emit('ROUND_COMPLETE', {
          round: game.currentRound - 1,
          nextRound: game.currentRound
        });

        // Show round intro with countdown
        setTimeout(() => {
          this.showRoundIntro(sessionId, game.currentRound);
        }, 1500);
      }
    } else {
      // Next question in current round
      this.nextQuestion(sessionId);
    }
  }
 // Submit answer
  async submitAnswer(sessionId, clientId, answerData) {
    const game = this.games.get(sessionId);
    if (!game || !game.currentQuestionData) {
      return { error: 'No active question' };
    }

    // Check if already answered
    if (game.currentQuestionData.answered.has(clientId)) {
      return { error: 'Already answered' };
    }

    // Check if player is frozen (speed round)
    if (game.currentRound === 4 && game.lightningRound.frozenPlayers.has(clientId)) {
      return { error: 'Frozen' };
    }

    game.currentQuestionData.answered.add(clientId);

    const responseTime = Date.now() - game.currentQuestionData.startTime;
    const timeLimit = game.currentRound === 4 ? 30000 : this.getTimeLimit(game.currentRound) * 1000;
    const isCorrect = answerData.answerIndex === game.currentQuestionData.correctAnswerIndex;

    // Calculate score with streak bonuses
    const scoring = this.calculateScore(
      game.currentRound,
      isCorrect,
      responseTime,
      timeLimit,
      game.players.get(clientId)?.currentStreak || 0
    );

    // Update player score
    const playerStats = game.players.get(clientId);
    playerStats.totalScore += scoring.finalScore;
    playerStats.hasAnswered = true;

    if (isCorrect) {
      playerStats.correctCount++;
      playerStats.currentStreak++;
      playerStats.longestStreak = Math.max(playerStats.longestStreak, playerStats.currentStreak);
      playerStats.roundCorrect[game.currentRound]++;
    } else {
      playerStats.currentStreak = 0;

      // Freeze player in speed round
      if (game.currentRound === 4) {
        game.lightningRound.frozenPlayers.add(clientId);
        this.io.to(clientId).emit('FROZEN', { duration: 3 });

        setTimeout(() => {
          game.lightningRound.frozenPlayers.delete(clientId);
          this.io.to(clientId).emit('UNFROZEN');
        }, 3000);
      }
    }

    // Check for perfect round bonus
    if (game.currentRound <= 3 && playerStats.roundCorrect[game.currentRound] === 10) {
      scoring.perfectRoundBonus = 500;
      scoring.finalScore += 500;
      playerStats.totalScore += 500;
    }

    // Emit answer result to the player
    this.io.to(clientId).emit('ANSWER_RESULT', {
      isCorrect,
      correctAnswerIndex: game.currentQuestionData.correctAnswerIndex,
      correctAnswerText: game.currentQuestionData.correct_answer,
      scoring: {
        ...scoring,
        responseTimeSeconds: (responseTime / 1000).toFixed(1),
        timeLimitSeconds: timeLimit / 1000
      },
      playerStats: {
        totalScore: playerStats.totalScore,
        correctCount: playerStats.correctCount,
        currentStreak: playerStats.currentStreak
      }
    });

    // Update host display
    this.emitGameState(sessionId);

    // Handle speed round progression
    if (game.currentRound === 4) {
      if (isCorrect) {
        game.lightningRound.questionsAnswered++;
        game.lightningRound.currentQuestionIndex++;

        // Show next question quickly
        setTimeout(() => {
          this.handleLightningQuestion(sessionId);
        }, 200);
      }
      // Wrong answers just freeze, don't advance
    } else if (game.currentRound <= 3) {
      // For regular rounds, auto-advance after answer
      if (!game.currentQuestionData.autoAdvanceStarted) {
        game.currentQuestionData.autoAdvanceStarted = true;

        setTimeout(() => {
          this.clearQuestionTimer(sessionId);
          this.clearFadeTimers(sessionId);
          this.io.to(sessionId).emit('QUESTION_COMPLETE', {
            correctAnswerIndex: game.currentQuestionData.correctAnswerIndex,
            correctAnswerText: game.currentQuestionData.correct_answer
          });

          setTimeout(() => {
            this.moveToNextQuestion(sessionId);
          }, 1500);
        }, 2000);
      }
    }

    return {
      isCorrect,
      correctAnswerIndex: game.currentQuestionData.correctAnswerIndex,
      scoring,
      playerStats: {
        totalScore: playerStats.totalScore,
        correctCount: playerStats.correctCount,
        currentStreak: playerStats.currentStreak
      }
    };
  }
// Calculate score with enhanced streak bonuses
  calculateScore(round, isCorrect, responseTimeMs, timeLimitMs, currentStreak = 0) {
    const basePoints = this.getBasePoints(round);
    const penalty = this.getPenalty(round);

    if (!isCorrect) {
      return {
        basePoints: 0,
        timeBonus: 0,
        penaltyPoints: round === 4 ? 0 : -penalty,
        streakBonus: 0,
        finalScore: round === 4 ? 0 : -penalty,
        breakdown: round === 4 ? 'Wrong answer - FROZEN!' : `Wrong answer: -${penalty} points`
      };
    }

    // Calculate time bonus (up to 50% extra for instant answers)
    const responseTimeSeconds = responseTimeMs / 1000;
    const timeLimitSeconds = timeLimitMs / 1000;

    const effectiveResponseTime = Math.min(responseTimeMs, timeLimitMs);
    const timeRatio = Math.max(0, 1 - (effectiveResponseTime / timeLimitMs));
    const timeBonus = round === 4 ? 0 : Math.floor(basePoints * 0.5 * timeRatio);
    const timeBonusPercentage = Math.floor(timeRatio * 50);

    // Calculate streak bonus
    let streakBonus = 0;
    let nextStreak = currentStreak + 1;

    if (nextStreak === 3) {
      streakBonus = 50;
    } else if (nextStreak === 5) {
      streakBonus = 100;
    } else if (nextStreak === 10) {
      streakBonus = 300;
    }

    const finalScore = basePoints + timeBonus + streakBonus;

    return {
      basePoints,
      timeBonus,
      penaltyPoints: 0,
      streakBonus,
      finalScore,
      responseTimeSeconds: responseTimeSeconds.toFixed(1),
      timeBonusPercentage,
      breakdown: `Base: ${basePoints} pts + Time bonus: ${timeBonus} pts + Streak bonus: ${streakBonus} pts = ${finalScore} pts`
    };
  }

  // End game
  async endGame(sessionId) {
    const game = this.games.get(sessionId);
    if (!game) return;

    game.status = 'completed';
    this.clearQuestionTimer(sessionId);
    this.clearFadeTimers(sessionId);

    // Clear lightning timer if exists
    const lightningTimer = this.lightningTimers.get(sessionId);
    if (lightningTimer) {
      clearTimeout(lightningTimer);
      this.lightningTimers.delete(sessionId);
    }

    // Update database
    try {
      await this.db('sessions')
        .where({ id: sessionId })
        .update({
          status: 'completed',
          ended_at: new Date()
        });
    } catch (error) {
      console.error(`[GameManager] Error updating session end time:`, error);
    }

    // Calculate final scores with bonuses
    const totalQuestions = 30 + game.lightningRound.questionsAnswered;
    const finalScores = Array.from(game.players.entries()).map(([clientId, stats]) => ({
      clientId,
      nickname: stats.nickname,
      totalScore: stats.totalScore,
      correctCount: stats.correctCount,
      accuracy: totalQuestions > 0 ? (stats.correctCount / totalQuestions) * 100 : 0,
      longestStreak: stats.longestStreak,
      perfectRounds: Object.entries(stats.roundCorrect)
        .filter(([round, correct]) => round <= 3 && correct === 10)
        .map(([round]) => parseInt(round))
    }));

    // Sort by score
    finalScores.sort((a, b) => b.totalScore - a.totalScore);

    console.log(`[GameManager] Game complete for session ${sessionId}`);

    // Emit game complete event
    this.io.to(sessionId).emit('GAME_COMPLETE', {
      finalScores,
      sessionId
    });

    // Clean up after delay
    setTimeout(() => {
      this.games.delete(sessionId);
    }, 300000); // Keep for 5 minutes
  }

  // Helper methods
  getTimeLimit(round) {
    const limits = { 1: 15, 2: 15, 3: 15, 4: 30 };
    return limits[round] || 15;
  }

  getBasePoints(round) {
    const points = { 1: 25, 2: 50, 3: 100, 4: 50 };
    return points[round] || 25;
  }

  getPenalty(round) {
    const penalties = { 1: 10, 2: 25, 3: 50, 4: 0 };
    return penalties[round] || 10;
  }

  getDifficultyForRound(round) {
    const difficulties = { 1: 'easy', 2: 'medium', 3: 'hard', 4: 'speed' };
    return difficulties[round] || 'medium';
  }

  // Get game state
  getGameState(sessionId) {
    return this.games.get(sessionId);
  }
}

module.exports = GameManager;
