// services/triviaAPIService.js - Hybrid implementation with OpenTDB and category progression
const axios = require('axios');
const knex = require('../db/connection');
const { questionCache } = require('../utils/cache');
const logger = require('../utils/logger');

class TriviaAPIService {
  constructor() {
    this.sources = {
      OPEN_TDB: 'https://opentdb.com/api.php',
    };

    this.difficultyMap = {
      easy: ['easy'],
      medium: ['medium'],
      hard: ['hard']
    };

    // Question slot configuration with primary and fallback categories
    this.questionSlots = [
      // Easy (Questions 1-6)
      { difficulty: 'easy', categories: [14, 32, 15] }, // Television → Cartoon & Animations → Video Games
      { difficulty: 'easy', categories: [12, 13, 11] }, // Music → Musicals & Theatres → Film
      { difficulty: 'easy', categories: [11, 10, 16] }, // Film → Books → Board Games
      { difficulty: 'easy', categories: [21, 26, 30] }, // Sports → Celebrities → Gadgets
      { difficulty: 'easy', categories: [26, 14, 23] }, // Celebrities → Television → History
      { difficulty: 'easy', categories: [27, 17, 22] }, // Animals → Science & Nature → Geography
      
      // Medium (Questions 7-8)
      { difficulty: 'medium', categories: [22, 20, 27] }, // Geography → Mythology → Animals
      { difficulty: 'medium', categories: [23, 24, 25] }, // History → Politics → Art
      
      // Hard (Questions 9-10)
      { difficulty: 'hard', categories: [18, 17, 30] }, // Computers → Science & Nature → Gadgets
      { difficulty: 'hard', categories: [20, 10, 23] }, // Mythology → Books → History
    ];

    // Category names for logging
    this.categoryNames = {
      9: 'General Knowledge',
      10: 'Entertainment: Books',
      11: 'Entertainment: Film',
      12: 'Entertainment: Music',
      13: 'Entertainment: Musicals & Theatres',
      14: 'Entertainment: Television',
      15: 'Entertainment: Video Games',
      16: 'Entertainment: Board Games',
      17: 'Science & Nature',
      18: 'Science: Computers',
      19: 'Science: Mathematics',
      20: 'Mythology',
      21: 'Sports',
      22: 'Geography',
      23: 'History',
      24: 'Politics',
      25: 'Art',
      26: 'Celebrities',
      27: 'Animals',
      28: 'Vehicles',
      29: 'Entertainment: Comics',
      30: 'Science: Gadgets',
      31: 'Entertainment: Japanese Anime & Manga',
      32: 'Entertainment: Cartoon & Animations'
    };
  }

  /**
   * Fetch questions for a session, storing them individually in the database
   * @param {string} sessionId - Session ID
   * @param {number} count - Total questions needed (default: 30)
   * @returns {Promise<Array>} Array of formatted questions
   */
  async fetchQuestions(sessionId, count = 30) {
    try {
      logger.info(`Fetching ${count} questions for session ${sessionId}`);

      // First, try to get existing questions from cache
      const cachedQuestions = await this.getSessionQuestionsFromDB(sessionId);
      if (cachedQuestions && cachedQuestions.length >= count) {
        logger.info(`Using ${cachedQuestions.length} cached questions for session ${sessionId}`);
        return cachedQuestions;
      }

      // Fetch new questions from APIs
      const questions = await this.fetchFromMultipleSources(count);

      // Store questions individually in the database
      await this.storeQuestionsInDB(questions, sessionId);

      return questions;
    } catch (error) {
      logger.error('Error fetching questions:', error);
      // Fall back to any existing questions in the database
      return await this.getFallbackQuestionsFromDB(count);
    }
  }

  /**
   * Get questions already assigned to a session
   */
  async getSessionQuestionsFromDB(sessionId) {
    return null; // Quick fix - disable DB cache, use API
    try {
      const questions = await knex('question_cache as qc')
        .join('session_questions as sq', 'qc.id', 'sq.question_cache_id')
        .where('sq.session_id', sessionId)
        .orderBy('sq.question_order')
        .select(
          'qc.*',
          'sq.round_number',
          'sq.question_order'
        );

      return questions.map(q => this.formatQuestionFromDB(q));
    } catch (error) {
      logger.error('Error getting session questions from DB:', error);
      return [];
    }
  }

  /**
   * Store questions individually in the database
   */
  async storeQuestionsInDB(questions, sessionId) {
    const trx = await knex.transaction();

    try {
      const storedQuestions = [];

      for (let i = 0; i < questions.length; i++) {
        const question = questions[i];
        const round = Math.floor(i / 10) + 1; // 10 questions per round

        // Check if question already exists by API ID or by exact text match
        let existingQuestion = null;

        if (question.api_id) {
          existingQuestion = await trx('question_cache')
            .where('api_question_id', question.api_id)
            .first();
        }

        if (!existingQuestion) {
          existingQuestion = await trx('question_cache')
            .where('question_text', question.text)
            .where('correct_answer', question.correct_answer)
            .first();
        }

        let questionId;

        if (existingQuestion) {
          questionId = existingQuestion.id;
          // Update usage count
          await trx('question_cache')
            .where('id', questionId)
            .increment('usage_count', 1)
            .update('last_used', new Date());
        } else {
          // Insert new question
          const [inserted] = await trx('question_cache').insert({
            api_question_id: question.api_id || `${question.source}_${Date.now()}_${i}`,
            question_text: question.text,
            correct_answer: question.correct_answer,
            incorrect_answers: JSON.stringify(question.incorrect_answers),
            category: question.category,
            difficulty: question.difficulty,
            tags: JSON.stringify(question.tags || []),
            regions: JSON.stringify(question.regions || []),
            usage_count: 1,
            last_used: new Date()
          }).returning('id');

          questionId = inserted.id;
        }

        // Link question to session
        await trx('session_questions').insert({
          session_id: sessionId,
          question_cache_id: questionId,
          question_order: i,
          round_number: round
        });

        storedQuestions.push({ ...question, id: questionId });
      }

      await trx.commit();
      logger.info(`Stored ${storedQuestions.length} questions for session ${sessionId}`);

      return storedQuestions;
    } catch (error) {
      await trx.rollback();
      logger.error('Error storing questions in DB:', error);
      throw error;
    }
  }

  /**
   * Fetch questions from multiple sources - Modified for category progression
   */
  async fetchFromMultipleSources(totalCount) {
    // For 10-question games, use category slot system
    if (totalCount === 10) {
      return await this.fetchQuestionsWithCategories(totalCount);
    }

    // For other counts (like 30), use traditional approach with even distribution
    const questionsPerDifficulty = Math.floor(totalCount / 3);
    const difficulties = ['easy', 'medium', 'hard'];
    const allQuestions = [];

    for (const difficulty of difficulties) {
      // Get questions from OpenTDB
      const openTDBQuestions = await this.fetchFromOpenTDB(questionsPerDifficulty, difficulty);
      allQuestions.push(...openTDBQuestions);

      // If we didn't get enough, use fallbacks
      const remaining = questionsPerDifficulty - openTDBQuestions.length;
      if (remaining > 0) {
        const fallback = await this.getFallbackQuestionsFromDB(remaining);
        allQuestions.push(...fallback);
      }
    }

    // Ensure we have exactly the required count
    if (allQuestions.length < totalCount) {
      const fallback = await this.getFallbackQuestionsFromDB(totalCount - allQuestions.length);
      allQuestions.push(...fallback);
    }

    // For non-10 question games, shuffle to mix difficulties
    return this.shuffleArray(allQuestions).slice(0, totalCount);
  }

  /**
   * Fetch questions using the category slot configuration (for 10-question games)
   */
  async fetchQuestionsWithCategories(totalCount) {
    const questions = [];
    const slotsToUse = this.questionSlots.slice(0, totalCount);

    for (let i = 0; i < slotsToUse.length && questions.length < totalCount; i++) {
      const slot = slotsToUse[i];
      let questionFetched = false;

      // Try each category in order until we get a question
      for (const categoryId of slot.categories) {
        if (questionFetched) break;

        try {
          const questionArray = await this.fetchFromOpenTDB(1, slot.difficulty, categoryId);
          
          if (questionArray && questionArray.length > 0) {
            questions.push(questionArray[0]);
            questionFetched = true;
            logger.info(`Question ${i + 1}: Successfully fetched ${slot.difficulty} question from ${this.categoryNames[categoryId]}`);
          }
        } catch (error) {
          logger.warn(`Failed to fetch from category ${this.categoryNames[categoryId]}: ${error.message}`);
        }
      }

      // If we couldn't get a question from any category, try without category filter
      if (!questionFetched) {
        try {
          const questionArray = await this.fetchFromOpenTDB(1, slot.difficulty);
          
          if (questionArray && questionArray.length > 0) {
            questions.push(questionArray[0]);
            logger.info(`Question ${i + 1}: Fetched ${slot.difficulty} question from any category`);
          }
        } catch (error) {
          logger.error(`Failed to fetch question ${i + 1} even without category filter: ${error.message}`);
        }
      }
    }

    // If we still don't have enough questions, fill with fallbacks
    if (questions.length < totalCount) {
      const fallback = await this.getFallbackQuestionsFromDB(totalCount - questions.length);
      questions.push(...fallback);
    }

    return questions;
  }

  /**
   * Fetch questions from OpenTDB
   */
  async fetchFromOpenTDB(count, difficulty, category = null) {
    try {
      const params = {
        amount: count,
        difficulty: difficulty,
        encode: 'url3986'
      };

      if (category) {
        params.category = category;
      }

      const response = await axios.get(this.sources.OPEN_TDB, {
        params: params,
        timeout: 5000
      });

      if (response.data.response_code !== 0) {
        // Response codes: 1 = No Results, 2 = Invalid Parameter, etc.
        if (response.data.response_code === 1) {
          throw new Error(`No questions available for category ${category} at ${difficulty} difficulty`);
        }
        throw new Error(`OpenTDB API error: ${response.data.response_code}`);
      }

      return response.data.results.map(q => {
        const correctAnswer = decodeURIComponent(q.correct_answer);
        const incorrectAnswers = q.incorrect_answers.map(a => decodeURIComponent(a));
        const allAnswers = this.shuffleArray([correctAnswer, ...incorrectAnswers]);
        const correctAnswerIndex = allAnswers.indexOf(correctAnswer);

        return {
          api_id: null, // OpenTDB doesn't provide IDs
          text: decodeURIComponent(q.question),
          question: decodeURIComponent(q.question),  // Add for compatibility
          category: decodeURIComponent(q.category),
          category_id: category,
          difficulty: difficulty,
          correct_answer: correctAnswer,
          incorrect_answers: incorrectAnswers,
          all_answers: allAnswers,
          correctAnswerIndex: correctAnswerIndex,  // FIXED: Added correctAnswerIndex
          source: 'opentdb',
          type: q.type,
          tags: [],
          regions: []
        };
      });
    } catch (error) {
      logger.error(`Error fetching from OpenTDB (${difficulty}${category ? `, category ${category}` : ''}):`, error.message);
      return [];
    }
  }

  /**
   * Get fallback questions from the database
   */
  async getFallbackQuestionsFromDB(count) {
    try {
      const questions = await knex('question_cache')
        .orderBy('usage_count', 'asc') // Prefer less-used questions
        .orderBy(knex.raw('RANDOM()'))
        .limit(count);

      return questions.map(q => this.formatQuestionFromDB(q));
    } catch (error) {
      logger.error('Error getting fallback questions:', error);
      return this.getHardcodedFallbackQuestions(count);
    }
  }

  /**
   * Format a question from database format to app format
   */
  formatQuestionFromDB(dbQuestion) {
    let incorrectAnswers = dbQuestion.incorrect_answers;
    if (typeof incorrectAnswers === 'string') {
      try {
        incorrectAnswers = JSON.parse(incorrectAnswers);
      } catch (e) {
        incorrectAnswers = [];
      }
    }

    const allAnswers = this.shuffleArray([dbQuestion.correct_answer, ...incorrectAnswers]);
    const correctAnswerIndex = allAnswers.indexOf(dbQuestion.correct_answer);

    return {
      id: dbQuestion.id,
      api_id: dbQuestion.api_question_id,
      text: dbQuestion.question_text,
      question: dbQuestion.question_text,  // Add for compatibility
      category: dbQuestion.category,
      difficulty: dbQuestion.difficulty,
      correct_answer: dbQuestion.correct_answer,
      incorrect_answers: incorrectAnswers,
      all_answers: allAnswers,
      correctAnswerIndex: correctAnswerIndex,  // FIXED: Added correctAnswerIndex
      source: dbQuestion.api_question_id?.split('_')[0] || 'database',
      type: 'multiple',
      tags: typeof dbQuestion.tags === 'string' ? JSON.parse(dbQuestion.tags) : dbQuestion.tags || [],
      regions: typeof dbQuestion.regions === 'string' ? JSON.parse(dbQuestion.regions) : dbQuestion.regions || []
    };
  }

  /**
   * Get hardcoded fallback questions as last resort
   */
  getHardcodedFallbackQuestions(count) {
    const fallbacks = [
      {
        text: "What is the capital of France?",
        category: "Geography",
        difficulty: "easy",
        correct_answer: "Paris",
        incorrect_answers: ["London", "Berlin", "Madrid"],
        source: "fallback"
      },
      {
        text: "Which planet is known as the Red Planet?",
        category: "Science",
        difficulty: "easy",
        correct_answer: "Mars",
        incorrect_answers: ["Venus", "Jupiter", "Saturn"],
        source: "fallback"
      },
      {
        text: "Who created Mickey Mouse?",
        category: "Entertainment",
        difficulty: "easy",
        correct_answer: "Walt Disney",
        incorrect_answers: ["Stan Lee", "Jim Henson", "Charles Schulz"],
        source: "fallback"
      },
      {
        text: "In which sport would you perform a slam dunk?",
        category: "Sports",
        difficulty: "easy",
        correct_answer: "Basketball",
        incorrect_answers: ["Tennis", "Golf", "Baseball"],
        source: "fallback"
      },
      {
        text: "What is the largest ocean on Earth?",
        category: "Geography",
        difficulty: "easy",
        correct_answer: "Pacific Ocean",
        incorrect_answers: ["Atlantic Ocean", "Indian Ocean", "Arctic Ocean"],
        source: "fallback"
      },
      {
        text: "Which animal is known as the 'King of the Jungle'?",
        category: "Animals",
        difficulty: "easy",
        correct_answer: "Lion",
        incorrect_answers: ["Tiger", "Elephant", "Gorilla"],
        source: "fallback"
      },
      {
        text: "Who painted the Mona Lisa?",
        category: "Art",
        difficulty: "medium",
        correct_answer: "Leonardo da Vinci",
        incorrect_answers: ["Pablo Picasso", "Vincent van Gogh", "Michelangelo"],
        source: "fallback"
      },
      {
        text: "In which year did World War II end?",
        category: "History",
        difficulty: "medium",
        correct_answer: "1945",
        incorrect_answers: ["1944", "1946", "1943"],
        source: "fallback"
      },
      {
        text: "What is the name of the first computer virus?",
        category: "Science: Computers",
        difficulty: "hard",
        correct_answer: "Creeper",
        incorrect_answers: ["ILOVEYOU", "Morris", "Brain"],
        source: "fallback"
      },
      {
        text: "Who was the Greek god of dreams?",
        category: "Mythology",
        difficulty: "hard",
        correct_answer: "Morpheus",
        incorrect_answers: ["Hypnos", "Thanatos", "Oneiros"],
        source: "fallback"
      }
    ];

    const questions = [];
    let fallbackIndex = 0;
    
    while (questions.length < count) {
      const q = fallbacks[fallbackIndex % fallbacks.length];
      const allAnswers = this.shuffleArray([q.correct_answer, ...q.incorrect_answers]);
      const correctAnswerIndex = allAnswers.indexOf(q.correct_answer);

      questions.push({
        ...q,
        id: `fallback_${questions.length}`,
        question: q.text,  // Add for compatibility
        all_answers: allAnswers,
        correctAnswerIndex: correctAnswerIndex,  // FIXED: Added correctAnswerIndex
        type: 'multiple',
        tags: [],
        regions: []
      });
      
      fallbackIndex++;
    }

    return questions.slice(0, count);
  }

  /**
   * Shuffle array using Fisher-Yates algorithm
   */
  shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  /**
   * Get questions for a specific round
   */
  async getQuestionsForRound(sessionId, roundNumber) {
    return []; // Quick fix - disable DB cache, use API
    try {
      const questions = await knex('question_cache as qc')
        .join('session_questions as sq', 'qc.id', 'sq.question_cache_id')
        .where('sq.session_id', sessionId)
        .where('sq.round_number', roundNumber)
        .orderBy('sq.question_order')
        .select('qc.*', 'sq.question_order');

      return questions.map(q => this.formatQuestionFromDB(q));
    } catch (error) {
      logger.error('Error getting round questions:', error);
      return [];
    }
  }
}

module.exports = new TriviaAPIService();
