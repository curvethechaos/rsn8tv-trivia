// services/triviaAPIService.js - Proper implementation for individual question storage
const axios = require('axios');
const knex = require('../db/connection');
const { questionCache } = require('../utils/cache');
const logger = require('../utils/logger');

class TriviaAPIService {
  constructor() {
    this.sources = {
      TRIVIA_API: 'https://the-trivia-api.com/api/questions',
      OPEN_TDB: 'https://opentdb.com/api.php',
    };

    this.difficultyMap = {
      easy: ['easy'],
      medium: ['medium'],
      hard: ['hard']
    };
  }

  /**
   * Fetch questions for a session, storing them individually in the database
   * @param {string} sessionId - Session ID
   * @param {number} count - Total questions needed (default: 30)
   * @returns {Promise<Array>} Array of formatted questions
   */
  async fetchQuestions(sessionId, count = 30) {
    try {
      logger.info(`Fetching ${count} questions for session ${sessionId}`);

      // First, try to get existing questions from cache
      const cachedQuestions = await this.getSessionQuestionsFromDB(sessionId);
      if (cachedQuestions && cachedQuestions.length >= count) {
        logger.info(`Using ${cachedQuestions.length} cached questions for session ${sessionId}`);
        return cachedQuestions;
      }

      // Fetch new questions from APIs
      const questions = await this.fetchFromMultipleSources(count);

      // Store questions individually in the database
      await this.storeQuestionsInDB(questions, sessionId);

      return questions;
    } catch (error) {
      logger.error('Error fetching questions:', error);
      // Fall back to any existing questions in the database
      return await this.getFallbackQuestionsFromDB(count);
    }
  }

  /**
   * Get questions already assigned to a session
   */
  async getSessionQuestionsFromDB(sessionId) {
    return null; // Quick fix - disable DB cache, use API
    try {
      const questions = await knex('question_cache as qc')
        .join('session_questions as sq', 'qc.id', 'sq.question_cache_id')
        .where('sq.session_id', sessionId)
        .orderBy('sq.question_order')
        .select(
          'qc.*',
          'sq.round_number',
          'sq.question_order'
        );

      return questions.map(q => this.formatQuestionFromDB(q));
    } catch (error) {
      logger.error('Error getting session questions from DB:', error);
      return [];
    }
  }

  /**
   * Store questions individually in the database
   */
  async storeQuestionsInDB(questions, sessionId) {
    const trx = await knex.transaction();

    try {
      const storedQuestions = [];

      for (let i = 0; i < questions.length; i++) {
        const question = questions[i];
        const round = Math.floor(i / 10) + 1; // 10 questions per round

        // Check if question already exists by API ID or by exact text match
        let existingQuestion = null;

        if (question.api_id) {
          existingQuestion = await trx('question_cache')
            .where('api_question_id', question.api_id)
            .first();
        }

        if (!existingQuestion) {
          existingQuestion = await trx('question_cache')
            .where('question_text', question.text)
            .where('correct_answer', question.correct_answer)
            .first();
        }

        let questionId;

        if (existingQuestion) {
          questionId = existingQuestion.id;
          // Update usage count
          await trx('question_cache')
            .where('id', questionId)
            .increment('usage_count', 1)
            .update('last_used', new Date());
        } else {
          // Insert new question
          const [inserted] = await trx('question_cache').insert({
            api_question_id: question.api_id || `${question.source}_${Date.now()}_${i}`,
            question_text: question.text,
            correct_answer: question.correct_answer,
            incorrect_answers: JSON.stringify(question.incorrect_answers),
            category: question.category,
            difficulty: question.difficulty,
            tags: JSON.stringify(question.tags || []),
            regions: JSON.stringify(question.regions || []),
            usage_count: 1,
            last_used: new Date()
          }).returning('id');

          questionId = inserted.id;
        }

        // Link question to session
        await trx('session_questions').insert({
          session_id: sessionId,
          question_cache_id: questionId,
          question_order: i,
          round_number: round
        });

        storedQuestions.push({ ...question, id: questionId });
      }

      await trx.commit();
      logger.info(`Stored ${storedQuestions.length} questions for session ${sessionId}`);

      return storedQuestions;
    } catch (error) {
      await trx.rollback();
      logger.error('Error storing questions in DB:', error);
      throw error;
    }
  }

  /**
   * Fetch questions from multiple sources
   */
  async fetchFromMultipleSources(totalCount) {
    const questionsPerDifficulty = Math.floor(totalCount / 3);
    const difficulties = ['easy', 'medium', 'hard'];
    const allQuestions = [];

    for (const difficulty of difficulties) {
      // Try to get from The Trivia API first
      const triviaAPIQuestions = await this.fetchFromTriviaAPI(questionsPerDifficulty, difficulty);
      allQuestions.push(...triviaAPIQuestions);

      // If we didn't get enough, try OpenTDB
      const remaining = questionsPerDifficulty - triviaAPIQuestions.length;
      if (remaining > 0) {
        const openTDBQuestions = await this.fetchFromOpenTDB(remaining, difficulty);
        allQuestions.push(...openTDBQuestions);
      }
    }

    // Ensure we have exactly the required count
    if (allQuestions.length < totalCount) {
      const fallback = await this.getFallbackQuestionsFromDB(totalCount - allQuestions.length);
      allQuestions.push(...fallback);
    }

    return this.shuffleArray(allQuestions).slice(0, totalCount);
  }

  /**
   * Fetch questions from The Trivia API
   */
  async fetchFromTriviaAPI(count, difficulty) {
    try {
      const response = await axios.get(this.sources.TRIVIA_API, {
        params: {
          limit: count,
          difficulty: difficulty
        },
        timeout: 5000
      });

      return response.data.map(q => {
        const allAnswers = this.shuffleArray([q.correctAnswer, ...q.incorrectAnswers]);
        const correctAnswerIndex = allAnswers.indexOf(q.correctAnswer);

        return {
          api_id: q.id,
          text: q.question,
          question: q.question,  // Add for compatibility
          category: q.category,
          difficulty: difficulty,
          correct_answer: q.correctAnswer,
          incorrect_answers: q.incorrectAnswers,
          all_answers: allAnswers,
          correctAnswerIndex: correctAnswerIndex,  // FIXED: Added correctAnswerIndex
          source: 'trivia-api',
          type: 'multiple',
          tags: q.tags || [],
          regions: q.regions || []
        };
      });
    } catch (error) {
      logger.error(`Error fetching from Trivia API (${difficulty}):`, error.message);
      return [];
    }
  }

  /**
   * Fetch questions from OpenTDB
   */
  async fetchFromOpenTDB(count, difficulty) {
    try {
      const response = await axios.get(this.sources.OPEN_TDB, {
        params: {
          amount: count,
          difficulty: difficulty,
          encode: 'url3986'
        },
        timeout: 5000
      });

      if (response.data.response_code !== 0) {
        throw new Error(`OpenTDB API error: ${response.data.response_code}`);
      }

      return response.data.results.map(q => {
        const correctAnswer = decodeURIComponent(q.correct_answer);
        const incorrectAnswers = q.incorrect_answers.map(a => decodeURIComponent(a));
        const allAnswers = this.shuffleArray([correctAnswer, ...incorrectAnswers]);
        const correctAnswerIndex = allAnswers.indexOf(correctAnswer);

        return {
          api_id: null, // OpenTDB doesn't provide IDs
          text: decodeURIComponent(q.question),
          question: decodeURIComponent(q.question),  // Add for compatibility
          category: decodeURIComponent(q.category),
          difficulty: difficulty,
          correct_answer: correctAnswer,
          incorrect_answers: incorrectAnswers,
          all_answers: allAnswers,
          correctAnswerIndex: correctAnswerIndex,  // FIXED: Added correctAnswerIndex
          source: 'opentdb',
          type: q.type,
          tags: [],
          regions: []
        };
      });
    } catch (error) {
      logger.error(`Error fetching from OpenTDB (${difficulty}):`, error.message);
      return [];
    }
  }

  /**
   * Get fallback questions from the database
   */
  async getFallbackQuestionsFromDB(count) {
    try {
      const questions = await knex('question_cache')
        .orderBy('usage_count', 'asc') // Prefer less-used questions
        .orderBy(knex.raw('RANDOM()'))
        .limit(count);

      return questions.map(q => this.formatQuestionFromDB(q));
    } catch (error) {
      logger.error('Error getting fallback questions:', error);
      return this.getHardcodedFallbackQuestions(count);
    }
  }

  /**
   * Format a question from database format to app format
   */
  formatQuestionFromDB(dbQuestion) {
    let incorrectAnswers = dbQuestion.incorrect_answers;
    if (typeof incorrectAnswers === 'string') {
      try {
        incorrectAnswers = JSON.parse(incorrectAnswers);
      } catch (e) {
        incorrectAnswers = [];
      }
    }

    const allAnswers = this.shuffleArray([dbQuestion.correct_answer, ...incorrectAnswers]);
    const correctAnswerIndex = allAnswers.indexOf(dbQuestion.correct_answer);

    return {
      id: dbQuestion.id,
      api_id: dbQuestion.api_question_id,
      text: dbQuestion.question_text,
      question: dbQuestion.question_text,  // Add for compatibility
      category: dbQuestion.category,
      difficulty: dbQuestion.difficulty,
      correct_answer: dbQuestion.correct_answer,
      incorrect_answers: incorrectAnswers,
      all_answers: allAnswers,
      correctAnswerIndex: correctAnswerIndex,  // FIXED: Added correctAnswerIndex
      source: dbQuestion.api_question_id?.split('_')[0] || 'database',
      type: 'multiple',
      tags: typeof dbQuestion.tags === 'string' ? JSON.parse(dbQuestion.tags) : dbQuestion.tags || [],
      regions: typeof dbQuestion.regions === 'string' ? JSON.parse(dbQuestion.regions) : dbQuestion.regions || []
    };
  }

  /**
   * Get hardcoded fallback questions as last resort
   */
  getHardcodedFallbackQuestions(count) {
    const fallbacks = [
      {
        text: "What is the capital of France?",
        category: "Geography",
        difficulty: "easy",
        correct_answer: "Paris",
        incorrect_answers: ["London", "Berlin", "Madrid"],
        source: "fallback"
      },
      {
        text: "Which planet is known as the Red Planet?",
        category: "Science",
        difficulty: "easy",
        correct_answer: "Mars",
        incorrect_answers: ["Venus", "Jupiter", "Saturn"],
        source: "fallback"
      },
      {
        text: "Who painted the Mona Lisa?",
        category: "Art",
        difficulty: "medium",
        correct_answer: "Leonardo da Vinci",
        incorrect_answers: ["Pablo Picasso", "Vincent van Gogh", "Michelangelo"],
        source: "fallback"
      }
    ];

    const questions = [];
    while (questions.length < count) {
      questions.push(...fallbacks.map((q, i) => {
        const allAnswers = this.shuffleArray([q.correct_answer, ...q.incorrect_answers]);
        const correctAnswerIndex = allAnswers.indexOf(q.correct_answer);

        return {
          ...q,
          id: `fallback_${questions.length + i}`,
          question: q.text,  // Add for compatibility
          all_answers: allAnswers,
          correctAnswerIndex: correctAnswerIndex,  // FIXED: Added correctAnswerIndex
          type: 'multiple',
          tags: [],
          regions: []
        };
      }));
    }

    return questions.slice(0, count);
  }

  /**
   * Shuffle array using Fisher-Yates algorithm
   */
  shuffleArray(array) {
    const shuffled = [...array];
    for (let i = shuffled.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
    }
    return shuffled;
  }

  /**
   * Get questions for a specific round
   */
  async getQuestionsForRound(sessionId, roundNumber) {
    return []; // Quick fix - disable DB cache, use API
    try {
      const questions = await knex('question_cache as qc')
        .join('session_questions as sq', 'qc.id', 'sq.question_cache_id')
        .where('sq.session_id', sessionId)
        .where('sq.round_number', roundNumber)
        .orderBy('sq.question_order')
        .select('qc.*', 'sq.question_order');

      return questions.map(q => this.formatQuestionFromDB(q));
    } catch (error) {
      logger.error('Error getting round questions:', error);
      return [];
    }
  }
}

module.exports = new TriviaAPIService();
