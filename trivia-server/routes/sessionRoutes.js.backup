// sessionRoutes.js - Session management routes
const express = require('express');
const router = express.Router();
const { v4: uuidv4 } = require('uuid');
const QRCode = require('qrcode');

// Create session endpoint
router.post('/create', async (req, res) => {
  try {
    const { hostId } = req.body;
    
    if (!hostId) {
      return res.status(400).json({ 
        success: false, 
        error: 'Host ID is required' 
      });
    }

    const db = req.app.locals.db;
    const gameManager = req.app.locals.gameManager;
    
    // Generate session details
    const sessionId = uuidv4();
    const roomCode = generateRoomCode();
    const baseUrl = process.env.BASE_URL || 'https://trivia.rsn8tv.com';
    const joinUrl = `${baseUrl}/join/${sessionId}`;
    
    // Generate QR code
    const qrCodeData = await QRCode.toDataURL(joinUrl);
    
    // Create session in database
    await db('sessions').insert({
      id: sessionId,
      host_id: hostId,
      room_code: roomCode,
      qr_code_data: qrCodeData,
      status: 'waiting',
      created_at: new Date(),
      expires_at: new Date(Date.now() + 3600000) // 1 hour
    });
    
    console.log(`Session created: ${sessionId}`);
    
    // Fetch questions for the session
    try {
      console.log(`Fetching questions for session ${sessionId}...`);
      
      // Use the existing trivia API service if available
      const triviaAPIService = req.app.locals.triviaAPIService;
      let questions = [];
      
      if (triviaAPIService && triviaAPIService.fetchQuestions) {
        questions = await triviaAPIService.fetchQuestions();
      } else {
        // Use fallback questions
        console.log('Using fallback questions');
        questions = generateFallbackQuestions(sessionID, 30);
      }
      
      // Cache questions in memory if cache service exists
      const cache = req.app.locals.cache;
      if (cache) {
        await cache.set(`questions:${sessionId}`, questions, 3600);
        console.log(`Cached ${questions.length} questions for session ${sessionId}`);
      }
      
      // Create game in GameManager with questions
      if (gameManager) {
        gameManager.createGame(sessionId, questions);
        console.log(`Game created in GameManager for session ${sessionId}`);
      } else {
        console.error('GameManager not initialized!');
      }
    } catch (questionError) {
      console.error('Error fetching questions:', questionError);
      // Use fallback questions
      const fallbackQuestions = generateFallbackQuestions();
      
      if (gameManager) {
        gameManager.createGame(sessionId, fallbackQuestions);
      }
    }
    
    const wsUrl = process.env.WS_URL || 'wss://trivia.rsn8tv.com';
    
    res.json({
      success: true,
      sessionId,
      roomCode,
      qrCode: qrCodeData,
      joinUrl,
      wsUrl: `${wsUrl}?sessionId=${sessionId}&role=host`
    });
    
  } catch (error) {
    console.error('Error creating session:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to create session' 
    });
  }
});

// Join session endpoint
router.post('/:sessionId/join', async (req, res) => {
  try {
    const { sessionId } = req.params;
    const { playerId, nickname } = req.body;
    
    if (!playerId || !nickname) {
      return res.status(400).json({ 
        success: false, 
        error: 'Player ID and nickname are required' 
      });
    }

    const db = req.app.locals.db;
    const profanityMiddleware = req.app.locals.profanityMiddleware;
    
    // Check if session exists and is active
    const session = await db('sessions')
      .where({ id: sessionId })
      .first();
    
    if (!session) {
      return res.status(404).json({ 
        success: false, 
        error: 'Session not found or expired' 
      });
    }
    
    // Check profanity
    try {
      if (profanityMiddleware && profanityMiddleware.checkProfanity) {
        const profanityCheck = await profanityMiddleware.checkProfanity(nickname);
        if (profanityCheck.hasProfanity) {
          return res.status(400).json({
            success: false,
            error: profanityCheck.message || 'Nickname contains inappropriate content'
          });
        }
      }
    } catch (profanityError) {
      console.error('Profanity check failed:', profanityError);
      // Continue without profanity check rather than crashing
    }
    
    // Check if player already exists
    const existingPlayer = await db('players')
      .where({ session_id: sessionId, client_id: playerId })
      .first();
    
    if (existingPlayer) {
      const wsUrl = process.env.WS_URL || 'wss://trivia.rsn8tv.com';
      return res.json({
        success: true,
        playerId: existingPlayer.client_id,
        nickname: existingPlayer.temporary_name,
        playerNumber: existingPlayer.player_number,
        isFirstPlayer: existingPlayer.player_number === 1,
        wsUrl: `${wsUrl}?sessionId=${sessionId}&role=player&clientId=${playerId}`
      });
    }
    
    // Get current player count
    const playerCount = await db('players')
      .where({ session_id: sessionId })
      .count('* as count')
      .first();
    
    const currentPlayerNumber = parseInt(playerCount.count) + 1;
    
    // Add player to session
    await db('players').insert({
      session_id: sessionId,
      client_id: playerId,
      temporary_name: nickname,
      // player_number not in schema
      created_at: new Date(),
      qr_scan_timestamp: new Date()
    });
    
    const wsUrl = process.env.WS_URL || 'wss://trivia.rsn8tv.com';
    
    res.json({
      success: true,
      playerId,
      nickname,
      playerNumber: currentPlayerNumber,
      isFirstPlayer: currentPlayerNumber === 1,
      wsUrl: `${wsUrl}?sessionId=${sessionId}&role=player&clientId=${playerId}`
    });
    
  } catch (error) {
    console.error('Error joining session:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to join session' 
    });
  }
});

// Get session questions (for testing)
router.get('/:sessionId/questions', async (req, res) => {
  try {
    const { sessionId } = req.params;
    const cache = req.app.locals.cache;
    let questions = [];
    
    if (cache) {
      questions = await cache.get(`questions:${sessionId}`);
    }
    
    if (!questions || questions.length === 0) {
      const gameManager = req.app.locals.gameManager;
      if (gameManager) {
        const game = gameManager.getGameState(sessionId);
        questions = game?.questions || [];
      }
    }
    
    if (!questions || questions.length === 0) {
      return res.status(404).json({ 
        success: false, 
        error: 'No questions found for session' 
      });
    }
    
    res.json({
      success: true,
      count: questions.length,
      questions: questions.slice(0, 3) // Return first 3 for testing
    });
    
  } catch (error) {
    console.error('Error fetching questions:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to fetch questions' 
    });
  }
});

// Submit score endpoint
router.post('/:sessionId/submit-score', async (req, res) => {
  try {
    const { sessionId } = req.params;
    const { clientId, email, nickname, realName, marketingConsent, finalScore } = req.body;
    
    if (!clientId || !email || !nickname || !realName) {
      return res.status(400).json({ 
        success: false, 
        error: 'All fields are required' 
      });
    }

    const db = req.app.locals.db;
    const profanityMiddleware = req.app.locals.profanityMiddleware;
    
    // Check profanity for nickname and real name
    try {
      if (profanityMiddleware && profanityMiddleware.checkProfanity) {
        const nicknameCheck = await profanityMiddleware.checkProfanity(nickname);
        const realNameCheck = await profanityMiddleware.checkProfanity(realName);
        
        if (nicknameCheck.hasProfanity || realNameCheck.hasProfanity) {
          return res.status(400).json({
            success: false,
            error: 'Name contains inappropriate content'
          });
        }
      }
    } catch (profanityError) {
      console.error('Profanity check failed:', profanityError);
      // Continue without profanity check rather than crashing
    }
    
    // Create player profile
    const [profileId] = await db('player_profiles').insert({
      email,
      nickname,
      real_name: realName,
      marketing_consent: marketingConsent || false,
      created_at: new Date()
    }).returning('id');
    
    // Update player record
    await db('players')
      .where({ session_id: sessionId, client_id: clientId })
      .update({ player_profile_id: profileId });
    
    // Add to leaderboards
    await db('leaderboards').insert({
      player_profile_id: profileId,
      session_id: sessionId,
      score: finalScore || 0,
      submitted_at: new Date()
    });
    
    res.json({
      success: true,
      message: 'Score submitted successfully',
      profileId
    });
    
  } catch (error) {
    console.error('Error submitting score:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Failed to submit score' 
    });
  }
});

// Helper function to generate room code
function generateRoomCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 4; i++) {
    code += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return code;
}

// Helper function to generate fallback questions
function generateFallbackQuestions() {
  const questions = [];
  const difficulties = ['easy', 'medium', 'hard'];
  
  for (let round = 1; round <= 3; round++) {
    for (let q = 1; q <= 10; q++) {
      questions.push({
        id: `r${round}q${q}`,
        question: `Round ${round} Question ${q}: What is the answer?`,
        answers: ['Answer A', 'Answer B', 'Answer C', 'Answer D'],
        correctAnswerIndex: Math.floor(Math.random() * 4),
        category: 'General',
        difficulty: difficulties[round - 1],
        text: `Round ${round} Question ${q}: What is the answer?` // Alternative property name
      });
    }
  }
  
  return questions;
}

module.exports = router;
